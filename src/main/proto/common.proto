syntax = "proto3";

package com.hymnsmobile.pipeline.models;

option java_multiple_files = true;

enum HymnType {
  DEFAULT = 0;
  CLASSIC_HYMN = 1;
  NEW_TUNE = 2;
  NEW_SONG = 3;
  CHILDREN_SONG = 4;
  HOWARD_HIGASHI = 5;
  DUTCH = 6;
  GERMAN = 7;
  CHINESE = 8;
  CHINESE_SIMPLIFIED = 9;
  CHINESE_SUPPLEMENTAL = 10;
  CHINESE_SUPPLEMENTAL_SIMPLIFIED = 11;
  CEBUANO = 12;
  TAGALOG = 13;
  FRENCH = 14;
  SPANISH = 15;
  KOREAN = 16;
  JAPANESE = 17;
  INDONESIAN = 18;
  FARSI = 19;
  BE_FILLED = 20;
  LIEDERBUCH = 21;
  BLUE_SONGBOOK = 22;
  SONGBASE = 23;
}

message Hymn {
  int32 id = 1;
  // Each hymn as a reference, but that doesn't mean it's the ONLY reference.
  // There exists a many-to-one relationship between references and hymns, as
  // many hymn books may reference the same hymn. However, for now, we still
  // keep this around because we need a "key" during the sanitization step,
  // where we try to reconcile language/relevant mappings. This is definitely
  // an area of improvement. If we can get rid of this field, and find another
  // way to key each song during the sanitization step, that would be best.
  // TODO figure out how we can get rid of this field
  SongReference reference = 2;
  string title = 3;
  repeated Verse lyrics = 4;
  repeated string category = 5;
  repeated string sub_category = 6;
  repeated string author = 7;
  repeated string composer = 8;
  repeated string key = 9;
  repeated string time = 10;
  repeated string meter = 11;
  repeated string scriptures = 12;
  repeated string hymn_code = 13;
  map<string, string> music = 14;
  map<string, string> svg_sheet = 15;
  map<string, string> pdf_sheet = 16;
  repeated SongLink languages = 17;
  repeated SongLink relevants = 18;
}

message SongReference {
  HymnType hymn_type = 1;
  string hymn_number = 2;
}

message SongLink {
  optional string name = 1;
  SongReference reference = 2;
}

message Verse {
  string verse_type = 1;
  repeated Line lines = 2;
}

message Line {
  string line_content = 1;
  optional string transliteration = 2;
}

message PipelineErrors {
  repeated PipelineError errors = 1;
}

// An error encountered during processing of the pipeline.
message PipelineError {
  enum Severity {
    // Should log error, but not the end of the world.
    WARNING = 0;
    // Blocks the hymn from ingestion but does not block the pipeline.
    ERROR = 1;
    // Blocks the entire pipeline from completion.
    FATAL = 2;
  }
  string message = 1;
  Severity severity = 2;
}